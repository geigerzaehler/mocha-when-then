// Generated by CoffeeScript 1.8.0
(function() {
  var GetterStep, Mocha, Promise, Step, TestStep, ValueStep, buildStepsTest, callWithAssigns, camelCase, factory, functionArguments, joinSteps, lastReturnExpression, specLabel, stepSpec,
    __slice = [].slice;

  Promise = require('promise');

  Mocha = require('mocha');

  module.exports = Mocha.interfaces['mocha-when-then'] = Mocha.interfaces['when-then'] = function(suite) {
    var suites;
    suites = [];
    return suite.on('pre-require', function(context, file, mocha) {
      context.describe = function(title, fn) {
        suites.push(suite);
        context.And = function() {
          throw Error('"And" keyword must be used after', '"Given", "When", or "Then"');
        };
        suite = Mocha.Suite.create(suite, title);
        suite.beforeAll(function() {
          this.assigns || (this.assigns = {});
          return this.getters || (this.getters = {});
        });
        suite.afterEach(function() {
          this.assigns = {};
          return this.getters = {};
        });
        suite.whens = [];
        suite.thens = [];
        fn.call(suite);
        buildStepsTest(suite);
        return suite = suites.pop();
      };
      context.describe.only = function(title, fn) {
        return context.describe(title, function() {
          mocha.grep(this.fullTitle());
          return fn.call(this);
        });
      };
      context.Given = function(name, executor) {
        var step;
        context.And = context.Given;
        step = Step(name, executor);
        return suite.beforeEach(function() {
          return step(this.assigns);
        });
      };
      context.Given.value = function(name, executor) {
        var step;
        context.And = context.Given;
        step = ValueStep(name, executor);
        return suite.beforeEach(function() {
          return step(this.assigns);
        });
      };
      context.Given.later = function(name, executor) {
        var step;
        context.And = context.Given;
        step = GetterStep(name, executor);
        return suite.beforeEach(function() {
          return step(this.assigns, this.getters);
        });
      };
      context.When = function(name, executor) {
        context.And = context.When;
        buildStepsTest(suite);
        return suite.whens.push(Step(name, executor));
      };
      context.When.value = function(name, executor) {
        context.And = context.When;
        buildStepsTest(suite);
        return suite.whens.push(ValueStep(name, executor));
      };
      context.Then = function(name, executor) {
        context.And = context.Then;
        return suite.thens.push(TestStep(name, executor));
      };
      return context.And = void 0;
    });
  };

  Step = function(name, executor) {
    var _ref;
    _ref = stepSpec(name, executor), executor = _ref.executor, name = _ref.name;
    return function(assigns) {
      return callWithAssigns(assigns, executor).then((function(_this) {
        return function(val) {
          if (name) {
            return assigns[name] = val;
          }
        };
      })(this));
    };
  };

  ValueStep = function(name, executor) {
    var _ref;
    _ref = stepSpec(name, executor), executor = _ref.executor, name = _ref.name;
    return function(assigns) {
      var value;
      value = callWithAssigns(assigns, executor);
      if (name) {
        assigns[name] = value;
      }
      return Promise.resolve();
    };
  };

  GetterStep = function(name, executor) {
    var _ref;
    _ref = stepSpec(name, executor), executor = _ref.executor, name = _ref.name;
    if (name == null) {
      throw Error('Given.later must be called with a label');
    }
    return function(assigns, getters) {
      console.log('define getter', name);
      getters[name] = function() {
        console.log('resolve getter', name);
        return callWithAssigns(assigns, executor);
      };
      return Promise.resolve();
    };
  };

  TestStep = function(label, fn) {
    var executor, name, run, _ref;
    _ref = stepSpec(label, fn), executor = _ref.executor, name = _ref.name;
    run = function(assigns, getters) {
      var n, names, values;
      if (name) {
        names = [name];
      } else {
        names = executor.argNames || [];
      }
      values = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          n = names[_i];
          _results.push(assigns[n] || (typeof getters[n] === "function" ? getters[n]() : void 0));
        }
        return _results;
      })();
      return Promise.all(values).then(function(values) {
        return executor.apply(assigns, values);
      }).then((function(_this) {
        return function(result) {
          if (result === false) {
            throw Error("Then statement returned 'false'");
          }
        };
      })(this));
    };
    run.label = specLabel(fn || label, name);
    return run;
  };

  joinSteps = function(steps) {
    var assigns, getters, next;
    steps = steps.slice();
    assigns = null;
    getters = null;
    next = function() {
      var step;
      if (step = steps.shift()) {
        return step(assigns, getters).then(next);
      }
    };
    return function() {
      assigns = this.assigns;
      getters = this.getters;
      return next();
    };
  };

  buildStepsTest = function(suite) {
    var runner, t, thens, whens, _i, _len;
    whens = suite.whens, thens = suite.thens;
    for (_i = 0, _len = thens.length; _i < _len; _i++) {
      t = thens[_i];
      runner = joinSteps(whens.concat([t]));
      suite.addTest(new Mocha.Test(t.label || '', runner));
    }
    if (thens.length) {
      suite.whens = [];
      return suite.thens = [];
    }
  };

  stepSpec = function(label, executor) {
    var name;
    if (executor == null) {
      executor = label;
      label = null;
    }
    if (label) {
      name = label.replace(/^(an?|the)\s+|(is|are)$/, '') || label;
      name = camelCase(name);
    }
    executor = factory(executor);
    return {
      name: name,
      executor: executor
    };
  };

  factory = function(fn) {
    var argNames, f;
    if (typeof fn.test === 'function') {
      argNames = functionArguments(fn.test);
      f = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return Promise.resolve(fn.test.apply(fn, args));
      };
    } else if (typeof fn === 'function') {
      argNames = functionArguments(fn);
      f = function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return Promise.resolve(fn.apply(this, args));
      };
    } else {
      f = function() {
        return Promise.resolve(fn);
      };
    }
    f.argNames = argNames;
    return f;
  };

  specLabel = function(fn, name) {
    var label;
    label = ['then'];
    if (name) {
      label.push(name);
    }
    if (fn.label != null) {
      label.push(fn.label);
    } else if (typeof fn === 'function') {
      label.push(lastReturnExpression(fn));
    } else {
      label.push('is', fn);
    }
    return label.join(' ');
  };

  lastReturnExpression = function(fn) {
    var blockEnd, expr, fnStart, returnExpr;
    fnStart = /^\s*function\s*\([^)]*\)\s*{\s*/;
    blockEnd = /\s*}\s*$/;
    returnExpr = /\s*return\s+([^;]+)\s*;\s*$/;
    expr = fn.toString().replace(fnStart, '').replace(blockEnd, '').match(returnExpr);
    return expr && expr[1];
  };

  functionArguments = function(fn) {
    var argMatch;
    argMatch = fn.toString().match(/function\s*\w*\s*\((.*?)\)/);
    if (argMatch) {
      return argMatch[1].split(/\s*,\s*/);
    }
  };

  callWithAssigns = function(assigns, fn) {
    var argNames, args, x, _i, _len;
    args = [];
    if (argNames = fn.argNames) {
      for (_i = 0, _len = argNames.length; _i < _len; _i++) {
        x = argNames[_i];
        args.push(assigns[x]);
      }
    }
    return fn.apply(assigns, args);
  };

  camelCase = function(string) {
    return string.replace(/[- ]([a-zA-Z])/g, function(_, start) {
      return start.toUpperCase();
    });
  };

}).call(this);
