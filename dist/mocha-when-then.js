// Generated by CoffeeScript 1.8.0
(function() {
  var Mocha, Promise, Step, TestStep, buildStepsTest, factory, joinSteps, lastReturnExpression, specLabel, stepSpec,
    __slice = [].slice;

  Promise = require('promise');

  Mocha = require('mocha');

  module.exports = Mocha.interfaces['mocha-when-then'] = Mocha.interfaces['when-then'] = function(suite) {
    var suites;
    suites = [];
    return suite.on('pre-require', function(context, file, mocha) {
      context.describe = function(title, fn) {
        suites.push(suite);
        context.And = function() {
          throw Error('"And" keyword must be used after', '"Given", "When", or "Then"');
        };
        suite = Mocha.Suite.create(suite, title);
        suite.beforeAll(function() {
          return this.assigns || (this.assigns = {});
        });
        suite.afterEach(function() {
          return this.assigns = {};
        });
        suite.whens = [];
        suite.thens = [];
        fn.call(suite);
        buildStepsTest(suite);
        return suite = suites.pop();
      };
      context.describe.only = function(title, fn) {
        context.describe(title, fn);
        return mocha.grep(suite.fullTitle());
      };
      context.Given = function(name, executor) {
        var step;
        context.And = context.Given;
        step = Step(name, executor);
        return suite.beforeEach(function() {
          return step(this.assigns);
        });
      };
      context.When = function(name, executor) {
        context.And = context.When;
        buildStepsTest(suite);
        return suite.whens.push(Step(name, executor));
      };
      context.Then = function(name, executor) {
        context.And = context.Then;
        return suite.thens.push(TestStep(name, executor));
      };
      return context.And = void 0;
    });
  };

  Step = function(name, executor) {
    var _ref;
    _ref = stepSpec(name, executor), executor = _ref.executor, name = _ref.name;
    return function(assigns) {
      return executor.call(assigns).then((function(_this) {
        return function(val) {
          if (name) {
            return assigns[name] = val;
          }
        };
      })(this));
    };
  };

  TestStep = function(label, fn) {
    var executor, name, run, _ref;
    _ref = stepSpec(label, fn), executor = _ref.executor, name = _ref.name;
    run = function(assigns) {
      return executor.call(assigns, name ? assigns[name] : void 0).then((function(_this) {
        return function(result) {
          if (result === false) {
            throw Error("Then statement returned 'false'");
          }
        };
      })(this));
    };
    run.label = specLabel(fn || label, name);
    return run;
  };

  joinSteps = function(steps) {
    var assigns, next;
    steps = steps.slice();
    assigns = null;
    next = function() {
      var step;
      if (step = steps.shift()) {
        return step(assigns).then(next);
      }
    };
    return function() {
      assigns = this.assigns;
      return next();
    };
  };

  buildStepsTest = function(suite) {
    var runner, t, thens, whens, _i, _len;
    whens = suite.whens, thens = suite.thens;
    for (_i = 0, _len = thens.length; _i < _len; _i++) {
      t = thens[_i];
      runner = joinSteps(whens.concat([t]));
      suite.addTest(new Mocha.Test(t.label || '', runner));
    }
    if (thens.length) {
      suite.whens = [];
      return suite.thens = [];
    }
  };

  stepSpec = function(label, executor) {
    var name;
    if (executor == null) {
      executor = label;
      label = null;
    }
    if (label) {
      name = label.replace(/^(an?|the)\s+|(is|are)$/, '') || label;
    }
    executor = factory(executor);
    return {
      name: name,
      executor: executor
    };
  };

  factory = function(fn) {
    if (typeof fn.test === 'function') {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return Promise.resolve(fn.test.apply(fn, args));
      };
    } else if (typeof fn === 'function') {
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return Promise.resolve(fn.apply(this, args));
      };
    } else {
      return function() {
        return Promise.resolve(fn);
      };
    }
  };

  specLabel = function(fn, name) {
    var label;
    label = ['then'];
    if (name) {
      label.push(name);
    }
    if (fn.label != null) {
      label.push(fn.label);
    } else if (typeof fn === 'function') {
      label.push(lastReturnExpression(fn));
    } else {
      label.push('is', fn);
    }
    return label.join(' ');
  };

  lastReturnExpression = function(fn) {
    var blockEnd, expr, fnStart, returnExpr;
    fnStart = /^\s*function\s*\([^)]*\)\s*{\s*/;
    blockEnd = /\s*}\s*$/;
    returnExpr = /\s*return\s+([^;]+)\s*;\s*$/;
    expr = fn.toString().replace(fnStart, '').replace(blockEnd, '').match(returnExpr);
    return expr && expr[1];
  };

}).call(this);
