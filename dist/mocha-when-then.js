// Generated by CoffeeScript 1.7.1
(function() {
  var __slice = [].slice;

  (function(global, factory) {
    if (typeof module === 'object' && typeof require === 'function') {
      return module.exports = factory(require('promise'), require('mocha'));
    } else {
      return factory(global.Promise, global.Mocha);
    }
  })(this, function(Promise, Mocha) {
    var Step, TestStep, buildStepsTest, factory, joinSteps, lastReturnExpression, specLabel, stepSpec, stepsInterface;
    Mocha.interfaces['steps'] = stepsInterface = function(suite) {
      var suites;
      suites = [];
      return suite.on('pre-require', function(context, file, mocha) {
        context.describe = function(title, fn) {
          suites.push(suite);
          suite = Mocha.Suite.create(suite, title);
          suite.beforeAll(function() {
            return this.assigns || (this.assigns = {});
          });
          suite.afterEach(function() {
            return this.assigns = {};
          });
          suite.whens = [];
          suite.thens = [];
          fn.call(suite);
          buildStepsTest(suite);
          return suite = suites.pop();
        };
        context.describe.only = function(title, fn) {
          context.describe(title, fn);
          return mocha.grep(suite.fullTitle());
        };
        context.Given = function(name, executor) {
          var step;
          step = Step(name, executor);
          return suite.beforeEach(function() {
            return step(this.assigns);
          });
        };
        context.When = function(name, executor) {
          buildStepsTest(suite);
          return suite.whens.push(Step(name, executor));
        };
        return context.Then = function(name, executor) {
          return suite.thens.push(TestStep(name, executor));
        };
      });
    };
    Step = function(name, executor) {
      var _ref;
      _ref = stepSpec(name, executor), executor = _ref.executor, name = _ref.name;
      return function(assigns) {
        return executor.call(assigns).then((function(_this) {
          return function(val) {
            if (name) {
              return assigns[name] = val;
            }
          };
        })(this));
      };
    };
    TestStep = function(label, fn) {
      var executor, name, run, _ref;
      _ref = stepSpec(label, fn), executor = _ref.executor, name = _ref.name;
      run = function(assigns) {
        return executor.call(assigns, name ? assigns[name] : void 0).then((function(_this) {
          return function(result) {
            if (result === false) {
              throw Error("Then statement returned 'false'");
            }
          };
        })(this));
      };
      run.label = specLabel(fn || label, name);
      return run;
    };
    joinSteps = function(steps) {
      var assigns, next;
      steps = steps.slice();
      assigns = null;
      next = function() {
        var step;
        if (step = steps.shift()) {
          return step(assigns).then(next);
        }
      };
      return function() {
        assigns = this.assigns;
        return next();
      };
    };
    buildStepsTest = function(suite) {
      var runner, t, thens, whens, _i, _len;
      whens = suite.whens, thens = suite.thens;
      for (_i = 0, _len = thens.length; _i < _len; _i++) {
        t = thens[_i];
        runner = joinSteps(whens.concat([t]));
        suite.addTest(new Mocha.Test(t.label || '', runner));
      }
      if (thens.length) {
        suite.whens = [];
        return suite.thens = [];
      }
    };
    stepSpec = function(label, executor) {
      var name;
      if (executor == null) {
        executor = label;
        label = null;
      }
      if (label) {
        name = label.replace(/^(an?|the)\s+|(is|are)$/, '') || label;
      }
      executor = factory(executor);
      return {
        name: name,
        executor: executor
      };
    };
    factory = function(fn) {
      if (typeof fn === 'function') {
        (function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return Promise.resolve(fn.apply(this, args));
        });
      }
      if (typeof fn.test === 'function') {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return Promise.resolve(fn.test.apply(fn, args));
        };
      } else {
        return function() {
          return Promise.resolve(fn);
        };
      }
    };
    specLabel = function(fn, name) {
      var label;
      label = ['then'];
      if (name) {
        label.push(name);
      }
      if (fn.specLabel != null) {
        label.push(fn.specLabel);
      } else if (typeof fn === 'function') {
        label.push(lastReturnExpression(fn));
      } else {
        label.push('is', fn);
      }
      return label.join(' ');
    };
    lastReturnExpression = function(fn) {
      var blockEnd, expr, fnStart, returnExpr;
      fnStart = /^\s*function\s*\([^)]*\)\s*{\s*/;
      blockEnd = /\s*}\s*$/;
      returnExpr = /\s*return\s+([^;]+)\s*;\s*$/;
      expr = fn.toString().replace(fnStart, '').replace(blockEnd, '').match(returnExpr);
      return expr && expr[1];
    };
    return stepsInterface;
  });

}).call(this);
